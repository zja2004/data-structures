# 链表 (Linked List)

## 概述

链表是一种线性数据结构，其中元素存储在节点中，每个节点包含数据和指向下一个节点的指针。与数组不同，链表的元素在内存中不需要连续存储。

## 链表类型

### 1. 单向链表 (Singly Linked List)
- 每个节点只有一个指向下一个节点的指针
- 只能从头到尾单向遍历

### 2. 双向链表 (Doubly Linked List)
- 每个节点有两个指针：指向前一个节点和下一个节点
- 可以双向遍历

### 3. 循环链表 (Circular Linked List)
- 最后一个节点指向第一个节点，形成环形结构

## 核心特性

- **动态大小**：可以在运行时动态增加或减少节点
- **高效插入/删除**：在已知位置插入或删除节点的时间复杂度为O(1)
- **内存效率**：只分配需要的内存空间
- **非连续存储**：节点可以分散在内存的任意位置

## 时间复杂度

| 操作 | 单向链表 | 双向链表 |
|------|----------|----------|
| 访问 | O(n) | O(n) |
| 搜索 | O(n) | O(n) |
| 插入(头部) | O(1) | O(1) |
| 插入(尾部) | O(n) | O(1)* |
| 插入(任意位置) | O(n) | O(n) |
| 删除(头部) | O(1) | O(1) |
| 删除(尾部) | O(n) | O(1)* |
| 删除(任意位置) | O(n) | O(n) |

*需要维护尾指针

## 空间复杂度

- **单向链表**：每个节点额外需要一个指针的空间
- **双向链表**：每个节点额外需要两个指针的空间

## 实现原理

### 节点结构

```cpp
// 单向链表节点
struct Node {
    T data;
    Node* next;
};

// 双向链表节点
struct Node {
    T data;
    Node* prev;
    Node* next;
};
```

### 内存布局

```
单向链表:
[数据|next] -> [数据|next] -> [数据|null]

双向链表:
null <- [prev|数据|next] <-> [prev|数据|next] <-> [prev|数据|next] -> null
```

## 优缺点比较

### 优点
- 动态大小，内存使用灵活
- 插入和删除操作高效（在已知位置）
- 不需要预先知道数据大小

### 缺点
- 不支持随机访问，查找效率低
- 额外的内存开销（存储指针）
- 缓存局部性差
- 不支持二分查找等算法

## 代码实现

- [单向链表实现](./singly_linked_list.h)
- [双向链表实现](./doubly_linked_list.h)
- [循环链表实现](./circular_linked_list.h)

## 使用示例

查看详细示例：[example.cpp](./example.cpp)

## 练习题

1. 实现链表的反转操作
2. 检测链表中是否有环
3. 找到链表的中间节点
4. 合并两个有序链表
5. 实现LRU缓存（使用双向链表+哈希表）

## 应用场景

- **动态数据管理**：数据大小经常变化的场景
- **插入删除频繁**：需要频繁在中间位置插入删除的场景
- **内存受限**：不能预先分配大块连续内存的环境
- **实现其他数据结构**：栈、队列、图的邻接表等
- **撤销操作**：编辑器的撤销功能
- **音乐播放列表**：支持插入、删除、循环播放

## 与数组的比较

| 特性 | 数组 | 链表 |
|------|------|------|
| 内存分配 | 连续 | 分散 |
| 访问时间 | O(1) | O(n) |
| 插入/删除 | O(n) | O(1)* |
| 内存开销 | 低 | 高 |
| 缓存友好性 | 好 | 差 |
| 实现复杂度 | 简单 | 中等 |

*在已知位置的情况下

---

**上一章：** [动态数组 (Vector)](../vector/README.md)  
**下一章：** [栈 (Stack)](../stack/README.md)